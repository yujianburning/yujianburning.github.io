{"meta":{"title":"Hexo","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"Hello World","slug":"hello-world","date":"2018-04-10T07:25:00.082Z","updated":"2017-08-02T01:19:46.613Z","comments":true,"path":"2018/04/10/hello-world/","link":"","permalink":"http://yoursite.com/2018/04/10/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"水平垂直居中","slug":"水平垂直居中","date":"2017-08-02T06:10:34.000Z","updated":"2017-08-02T06:53:29.315Z","comments":true,"path":"2017/08/02/水平垂直居中/","link":"","permalink":"http://yoursite.com/2017/08/02/水平垂直居中/","excerpt":"","text":"前端开发元素的垂直水平居中是不可缺少的，在开发中容易混淆，而达不到想要的效果，下面介绍几种常用的方法。 水平居中1、align:center；行内元素，写给父级2、margin:0 auto；块级元素，写给自身3、just-content:center；新版flex，写给父级html结构123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;son&quot;&gt;&lt;/div&gt; &lt;/div&gt; css样式 12345678910111213 .parent&#123; display:-webkit-flex; /*声明弹性盒模型,定义弹性容器*/ -webkit-flex-direction:row; /*row设置主轴方向为水平方向*/ -webkit-justify-content:center; /*定义了在当前行上,弹性项目沿主轴如何排布*/ display:flex; flex-direction:row; justify-content:center; /*相当于老版本的box-pack*/&#125;.son&#123; width:100px; height:100px; background:blue; &#125; 4、绝对定位垂直居中1、height与line-height相等；只适用于单行文本的元素才适用,比如块级元素里面文本2、vertical-align:middle；适用于行内块html结构123&lt;div class=&quot;parent&quot;&gt; ![](img/QrCode.jpg)&lt;/div&gt; css样式1234567891011121314151617.parent&#123; width:500px; height:500px; border:1px solid red;&#125;.parent::after, .son&#123; /*父级元素和子元素都设置display:inline-block*/ display:inline-block; vertical-align: middle; /*设置vertical-align:middle*/&#125;.parent::after&#123; /*父元素添加一个伪类,并且设置高度100%*/ content:&quot;&quot;; height:100%;&#125;img&#123; border:1px solid blue; border-left:none;&#125; 3、align-items:centerhtml结构123&lt;div class=&quot;parent&quot;&gt; &lt;div class=&quot;son&quot;&gt;1&lt;/div&gt;&lt;/div&gt; css样式12345678910111213.parent&#123; height:400px; display:-webkit-flex; display:flex; flex-direction: row;/*容器内项目的排列方向(默认横向排列),row表示沿水平主轴由左向右排列,column沿垂直主轴右上到下 */ align-items: center; /*居中*/ border:1px solid red;&#125;.son&#123; width:100px; height:100px; background:orange;&#125; 4、定位","categories":[],"tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"es6","slug":"es6","date":"2017-03-10T03:19:04.000Z","updated":"2018-04-10T08:49:24.939Z","comments":true,"path":"2017/03/10/es6/","link":"","permalink":"http://yoursite.com/2017/03/10/es6/","excerpt":"1、let块级作用域用来声明变量，用法类似于var，但所声明的变量只在let命令所在的代码块内有效。123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined","text":"1、let块级作用域用来声明变量，用法类似于var，但所声明的变量只在let命令所在的代码块内有效。123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。let不允许在相同作用域内，重复声明同一个变量。 2、const 常量const声明一个只读的常量。一旦声明，常量的值就不能改变。const的作用域与let命令相同：只在声明所在的块级作用域内有效。 3、字符串的扩展方法for ··· of 循环遍历123for (let codePoint of 'foo') &#123; console.log(codePoint)&#125; 4、字符串是否包含另一个字符12345var s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false includes()：返回布尔值，表示是否找到了参数字符串。startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 5、函数参数设置默认值1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;var p = new Point();p // &#123; x: 0, y: 0 &#125; 参数变量是默认声明的，所以不能用let或const再次声明1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 使用参数默认值时，函数不能有同名参数。参数默认值可以与解构赋值的默认值，结合起来使用。12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined, 5foo(&#123;x: 1&#125;) // 1, 5foo(&#123;x: 1, y: 2&#125;) // 1, 2foo() // TypeError: Cannot read property 'x' of undefined 只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值而生成。如果函数foo调用时参数不是对象，变量x和y就不会生成，从而报错。","categories":[{"name":"-Js","slug":"Js","permalink":"http://yoursite.com/categories/Js/"}],"tags":[{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]}]}